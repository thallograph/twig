/**
 * @since 1.0.0
 */
import * as Cause from "effect/Cause";
import * as Context from "effect/Context";
import * as Data from "effect/Data";
import * as Effect from "effect/Effect";
import * as Exit from "effect/Exit";
import * as Fiber from "effect/Fiber";
import { constFalse, constTrue, dual, identity } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Option from "effect/Option";
import * as Predicate from "effect/Predicate";
import * as PrimaryKey from "effect/PrimaryKey";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import { makeHashDigest } from "./internal/crypto.js";
/**
 * @since 1.0.0
 * @category Symbols
 */
export const TypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow");
const EngineTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine");
const InstanceTag = /*#__PURE__*/Context.GenericTag("@effect/workflow/WorkflowEngine/WorkflowInstance");
/**
 * @since 1.0.0
 * @category Constructors
 */
export const make = options => {
  const makeExecutionId = payload => makeHashDigest(`${options.name}-${options.idempotencyKey(payload)}`);
  const self = {
    [TypeId]: TypeId,
    name: options.name,
    payloadSchema: Schema.isSchema(options.payload) ? options.payload : Schema.Struct(options.payload),
    successSchema: options.success ?? Schema.Void,
    errorSchema: options.error ?? Schema.Never,
    annotations: options.annotations ?? Context.empty(),
    annotate(tag, value) {
      return make({
        ...options,
        annotations: Context.add(self.annotations, tag, value)
      });
    },
    annotateContext(context) {
      return make({
        ...options,
        annotations: Context.merge(self.annotations, context)
      });
    },
    execute: Effect.fnUntraced(function* (fields, opts) {
      const payload = self.payloadSchema.make(fields);
      const engine = yield* EngineTag;
      const executionId = yield* makeExecutionId(payload);
      yield* Effect.annotateCurrentSpan({
        executionId
      });
      return yield* engine.execute(self, {
        executionId,
        payload,
        discard: opts?.discard,
        suspendedRetrySchedule: options.suspendedRetrySchedule
      });
    }, Effect.withSpan(`${options.name}.execute`, {
      captureStackTrace: false
    })),
    poll: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      return yield* engine.poll(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.poll`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    interrupt: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.interrupt(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.interrupt`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    resume: Effect.fnUntraced(function* (executionId) {
      const engine = yield* EngineTag;
      yield* engine.resume(self, executionId);
    }, (effect, executionId) => Effect.withSpan(effect, `${options.name}.resume`, {
      captureStackTrace: false,
      attributes: {
        executionId
      }
    })),
    toLayer: execute => Layer.scopedDiscard(Effect.gen(function* () {
      const engine = yield* EngineTag;
      return yield* engine.register(self, execute);
    })),
    executionId: payload => makeExecutionId(self.payloadSchema.make(payload)),
    withCompensation
  };
  return self;
};
/**
 * @since 1.0.0
 * @category Constructors
 */
export const fromTaggedRequest = (schema, options) => make({
  name: schema._tag,
  payload: schema,
  success: schema.success,
  error: schema.failure,
  idempotencyKey: PrimaryKey.value,
  suspendedRetrySchedule: options?.suspendedRetrySchedule
});
/**
 * @since 1.0.0
 * @category Result
 */
export const ResultTypeId = /*#__PURE__*/Symbol.for("@effect/workflow/Workflow/Result");
/**
 * @since 1.0.0
 * @category Result
 */
export const isResult = u => Predicate.hasProperty(u, ResultTypeId);
/**
 * @since 1.0.0
 * @category Result
 */
export class Complete extends /*#__PURE__*/Data.TaggedClass("Complete") {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
  /**
   * @since 1.0.0
   */
  static SchemaFromSelf(_options) {
    return Schema.declare(u => isResult(u) && u._tag === "Complete");
  }
  /**
   * @since 1.0.0
   */
  static SchemaEncoded(options) {
    return Schema.Struct({
      _tag: Schema.tag("Complete"),
      exit: Schema.Exit({
        success: options.success,
        failure: options.error,
        defect: Schema.Defect
      })
    });
  }
  /**
   * @since 1.0.0
   */
  static Schema(options) {
    return Schema.transform(this.SchemaEncoded(options), this.SchemaFromSelf(options), {
      decode(fromA) {
        return new Complete({
          exit: fromA.exit
        });
      },
      encode(toI) {
        return toI;
      }
    });
  }
}
/**
 * @since 1.0.0
 * @category Result
 */
export class Suspended extends /*#__PURE__*/Schema.TaggedClass("@effect/workflow/Workflow/Suspended")("Suspended", {
  cause: /*#__PURE__*/Schema.optional(/*#__PURE__*/Schema.Cause({
    error: Schema.Never,
    defect: Schema.Defect
  }))
}) {
  /**
   * @since 1.0.0
   */
  [ResultTypeId] = ResultTypeId;
}
/**
 * @since 1.0.0
 * @category Result
 */
export const Result = options => Schema.Union(Complete.Schema(options), Suspended);
/**
 * @since 1.0.0
 * @category Result
 */
export const intoResult = effect => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const captureDefects = Context.get(instance.workflow.annotations, CaptureDefects);
  const suspendOnFailure = Context.get(instance.workflow.annotations, SuspendOnFailure);
  return effect.pipe(
  // So we can use external interruption to suspend a workflow
  Effect.fork, Effect.flatMap(fiber => Effect.onInterrupt(Fiber.join(fiber), () => Fiber.interrupt(fiber))), Effect.interruptible, suspendOnFailure ? Effect.catchAllCause(cause => {
    instance.suspended = true;
    if (!Cause.isInterruptedOnly(cause)) {
      instance.cause = Cause.die(Cause.squash(cause));
    }
    return Effect.interrupt;
  }) : identity, Effect.scoped, Effect.matchCauseEffect({
    onSuccess: value => Effect.succeed(new Complete({
      exit: Exit.succeed(value)
    })),
    onFailure: cause => instance.suspended ? Effect.succeed(new Suspended({
      cause: instance.cause
    })) : !instance.interrupted && Cause.isInterruptedOnly(cause) || !captureDefects && Cause.isDie(cause) ? Effect.failCause(cause) : Effect.succeed(new Complete({
      exit: Exit.failCause(cause)
    }))
  }), Effect.onExit(exit => {
    if (Exit.isFailure(exit)) {
      return Scope.close(instance.scope, exit);
    } else if (exit.value._tag === "Complete") {
      return Scope.close(instance.scope, exit.value.exit);
    }
    return Effect.void;
  }), Effect.uninterruptible);
});
/**
 * @since 1.0.0
 * @category Result
 */
export const wrapActivityResult = (effect, isSuspend) => Effect.contextWithEffect(context => {
  const instance = Context.get(context, InstanceTag);
  const state = instance.activityState;
  if (instance.suspended) {
    return waitForZero(instance).pipe(Effect.andThen(suspend(instance)));
  }
  if (state.count === 0) state.latch.unsafeClose();
  state.count++;
  return Effect.onExit(effect, exit => {
    state.count--;
    const isSuspended = Exit.isSuccess(exit) && isSuspend(exit.value);
    if (Exit.isSuccess(exit) && isResult(exit.value) && exit.value._tag === "Suspended" && exit.value.cause) {
      instance.cause = instance.cause ? Cause.sequential(instance.cause, exit.value.cause) : exit.value.cause;
    }
    return state.count === 0 ? state.latch.open : isSuspended ? waitForZero(instance) : Effect.void;
  });
});
const waitForZero = /*#__PURE__*/Effect.fnUntraced(function* (instance) {
  const state = instance.activityState;
  while (true) {
    if (state.count > 0) {
      yield* state.latch.await;
      yield* Effect.yieldNow();
      continue;
    }
    yield* Effect.yieldNow();
    if (state.count === 0) return;
  }
});
/**
 * Accesses the workflow scope.
 *
 * The workflow scope is only closed when the workflow execution fully
 * completes.
 *
 * @since 1.0.0
 * @category Scope
 */
export const scope = /*#__PURE__*/Effect.map(InstanceTag, instance => instance.scope);
/**
 * Provides the workflow scope to the given effect.
 *
 * The workflow scope is only closed when the workflow execution fully
 * completes.
 *
 * @since 1.0.0
 * @category Scope
 */
export const provideScope = effect => Effect.flatMap(scope, scope => Scope.extend(effect, scope));
/**
 * @since 1.0.0
 * @category Scope
 */
export const addFinalizer = /*#__PURE__*/Effect.fnUntraced(function* (f) {
  const scope = (yield* InstanceTag).scope;
  const runtime = yield* Effect.runtime();
  yield* Scope.addFinalizerExit(scope, exit => Effect.provide(f(exit), runtime));
});
/**
 * Add compensation logic to an effect inside a Workflow. The compensation finalizer will be
 * called if the entire workflow fails, allowing you to perform cleanup or
 * other actions based on the success value and the cause of the workflow failure.
 *
 * NOTE: Compensation will not work for nested activities. Compensation
 * finalizers are only registered for top-level effects in the workflow.
 *
 * @since 1.0.0
 * @category Compensation
 */
export const withCompensation = /*#__PURE__*/dual(2, (effect, compensation) => Effect.uninterruptibleMask(restore => Effect.tap(restore(effect), value => addFinalizer(exit => Exit.isSuccess(exit) ? Effect.void : compensation(value, exit.cause)))));
/**
 * @since 1.0.0
 */
export const suspend = instance => Effect.interruptible(Effect.async(() => {
  instance.suspended = true;
  const fiber = Option.getOrThrow(Fiber.getCurrentFiber());
  fiber.unsafeInterruptAsFork(fiber.id());
}));
/**
 * If you set this annotation to `true` for a workflow, it will capture defects
 * and include them in the result of the workflow or it's activities.
 *
 * By default, this is set to `true`, meaning that defects will be captured.
 *
 * @since 1.0.0
 * @category Annotations
 */
export class CaptureDefects extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/CaptureDefects", {
  defaultValue: constTrue
}) {}
/**
 * If you set this annotation to `true` for a workflow, it will suspend if it
 * encounters any kind of error.
 *
 * You can then manually resume the workflow later with
 * `Workflow.resume(executionId)`.
 *
 * @since 1.0.0
 * @category Annotations
 */
export class SuspendOnFailure extends /*#__PURE__*/Context.Reference()("@effect/workflow/Workflow/SuspendOnFailure", {
  defaultValue: constFalse
}) {}
//# sourceMappingURL=Workflow.js.map